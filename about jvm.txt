java jvm分为程序计数器、虚拟机栈、虚拟机堆、本地方法栈、方法区五个部分。
其中程序计数器、虚拟机栈、本地方法栈三个部分线程私有；虚拟机堆、方法两部分线程共享

程序计数器：代码循环、跳转等根据程序计数器有序执行，每个执行代码线程都会有独立的程序计数器，是jvm中唯一不会发证内存泄漏的区域
虚拟机栈：存放java对象的模型，有本地变量表、操作栈两部分，方法的调用到结束对应一次栈帧入栈到出栈的过程
虚拟机堆：存放对象实例的区域，每个新建的对象都会在虚拟机堆里开辟内存；垃圾回收的主要区域，也成为“GC堆”；分为新生代和老年代，对应有不同的内存回收机制，提高了效率，新生代内存收集采用复制算法，老年代采用标记清理算法
本地方法栈：调用native方法
方法区：存储静态变量、常量、及时编译的代码信息

判断对象是否或者的几种算法：
1.引用计数算法：有引用+1，失去引用-1，计数器为0时，则对象已死亡
2.根搜索算法：通过一系列名为"GC ROOTS"的对象作为起始点，从这节点开始向下搜索，搜索所经过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连，则此对象是不可用的。

可作为GC ROOTS的对象：
	(1)虚拟机栈中本地变量表引用的对象
	(2)方法区中的常量引用的对象
	(3)方法区的静态变量引用的对象
	(4)本地方法栈native方法的引用的对象

类加载过程：jvm把编译后的.class文件中的类信息加载到内存，并解析生成对象的class对象过程。
类加载过程主要分为以下几部分：加载、验证、准备、解析、初始化、使用、卸载。
类加载加载时使用双亲委派机制：当一个类加载器收到类加载请求时，首先判断这个类是否被加载过，如果没被加载过他并不会直接去加载这个类，而是把这个请求委派给他的父类（自定义类加载器->application classLoader->extendsion classLoader->bootstrap classLoader），直至最顶层的Bootstrap ClassLoader，如果父类加载失败，就会尝试让子类加载,子类也都加载的时候，就会报出ClassNotFoundException
